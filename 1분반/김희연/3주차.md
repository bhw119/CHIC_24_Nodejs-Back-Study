# Node.js 1장 Chapter 28~48

## 28 Node.js- 동기와 비동기 그리고 콜백

**동기 처리 방식(synchronous):** 하나의 작업이 끝날 때까지 기다렸다가 다음 작업을 처리하는 방식

**비동기 처리 방식(asynchronous):** 병렬로 동시에 여러 가지 일을 처리하는 방식

—> Node.js는 비동기 처리를 하기 위한 아주 좋은 기능을 제공

**동기 처리 방식)**

```jsx
var fs=require('fs'); // require 를 이용하여 파일 시스템에 관한 기능이 담긴 fs모듈을 불러와서 fs변수에 담음.

//readFileSync
console.log('A');
var result=fs.readFIleSync('syntax/sample.txt','utf8'); // 동기 처리 방식으로 동작하는 readFIleSync기능을 사용해 sample.txt파일을 utf8혀식으로 읽어서 result변수에 담음. 
console.log(result);
console.log('C');

// 명령을 작성한 순서대로 출력되는 모습--> 각 명령을 처리할 떄까지 기다렸다가 마치면 다음 명령 실행하는 것. 
```

**비동기 처리 방식)**

```jsx
var fs=require('fs'); // require 를 이용하여 파일 시스템에 관한 기능이 담긴 fs모듈을 불러와서 fs변수에 담음.

//readFile
console.log('A');
fs.readFile('syntax/sample.txt','utf8',function(err,result){
  console.log(result);

});
console.log('C');

// Node.js가 파일 읽기를 마치면 세 번쨰 매개변수로 전달한 함수를 자동으로 호출해서 함수의 본문을 실행함. 
//function으로 정의한 첫 번째 매개변수에는 에러가 있다면 에러가 전달되고, 두 번쨰 매개변수 result에는 파일을 읽어서 가져온 내용이 저장됨. 
```

readFile형식에서는 세 번째 매개변수에 readFileSync에는 없었던 callback이라는 것이 있음. 

—> 동기 처리 방식으로 동작할 때는 파일을 읽어서 result변수에 담아서 사용했지만, 비동기 처리 방식으로 동작하는 readFIle기능은 결괏값을 반환하지 않음 

따라서 변수에 담아서 사용할 수 없고, 대신 callback자리에 전달한 함수를 이용

실행 흐름과 별도(비동기)로 동작해서 처리 시간이 실행 흐름에 영향을 미치지 않음. 

**콜백(callback):** 어떤 실행문을 마치면 내부적으로 자동 호출하는 기능

```jsx
var a=function (){   // 익명함수(함수에 이름이 없는 것.)는 호출이 불가능하므로 익명함수에 변수를 선언해주는 것.
  console.log('A');
}

// slowfunc 함수가 끝나면 자동으로 어떤 함수를 호출해달라고 할 때 콜백 사용하는 것.
function slowfunc(callback){  // slowfunc함수는 콜백을 매개변수로 받아서 호출
      callback();
}
slowfunc(a); // slowfunc()함수를 호출할 때 slowfunc()함수가 실행된 다음에 호출할 함수를 인수로 전달해야하는 것.

```

—> 함수가 변숫값이 됨. 자바스크립트에서는 함수가 값을 의미.

## 29 Node.js-패키지 매니저와 PM2

**패키지:** 소프트웨어를 일컫는 여러 가지 표현 중 하나, 독립적으로 실행되는 프로그램, 어떤 프로그램 안에서 부품으로 사용되는 작은 프로그램

- **PM2:** Node.js로 만든 프로세스(동작 중인 프로그램, ex) main.js)를 관리해주는 프로그램, 프로그램을 감시하고 있다가 의도하지 않게 꺼지거나 소스가 변경될 때 자동으로 재시동 함으로써 서비스를 안정적으로 유지하게 도움.

**패키지 매니저:** 패키지를 설치, 업데이트, 삭제하는 등 관리하는 데 도움을 주는 프로그램 

- **npm**: Node.js에서 가장 광범위하게 사용되며, Node.js를 설치할 때 함께 설치되는 기본 패키지 매니저

—> PM2는 Node.js 애플리케이션의 실행과 관리를 도와주는 패키지(도구)이고, npm은 Node.js환경에서 사용하는 패키지들을 설치하고 관리하는 패키지 매니저이다. 

### PM2 설치

```jsx
> npm install pm2 -g  
```

—> npm을 통해 PM2를 설치하는데 이 컴퓨터의 어느 위치에서나 실행할 수 있게 설정(-g 옵션)해달라는 의미

### PM2 실행

```jsx
> pm2 start main.js 
```

—> 실행시키면 출력 결과로 나온 표에서 Name: 우리가 실행한 프로그램 이름, status(상태)가 online이면 실행 중이라는 의미, 그리고 실행 시간을 비롯하여 CPU나 메모리 등 시스템 자원을 얼마나 소비하고 있는 지를 보여줌

### 프로세스 감시

```jsx
> pm2 monit
```

—> 현재 PM2가 감시하는 프로세스 정보가 나타남. 프로세스 관리자에서 실행 중인 Node.js 프로세스를 강제로 종료해도 PM2가 자동으로 재시동 하여 서비스를 안정적으로 운영할 수 있게 해줌. 

### 프로세스 목록 확인과 중단

```jsx
> pm2 list
> pm2 stop main
```

### 소스 파일 감시

```jsx
> pm2 start main.js --watch
```

—> 소스를 고치고 프로그램을 재시동했던 방식을 자동화할 수 있는 것. PM2를 실행할 때- -watch 옵션으로 켤 수 있음.

**문제:** PM2가 자동으로 재시동해주면 에러에 대한 메시지를 볼 수 없음 

>pm2 log  명령을 통해서 문제를 확인할 수 있음. 

## 30 HTML-Form

외부에서 누구나 데이터를 전송함으로써 콘텐츠를 생성, 수정, 삭제할 수 있게 하기.

HTML 폼 기능: 사용자가 서버 쪽으로 데이터를 전송하는 방식

```jsx
// 사용자로부터 입력받는 양식을 <form>태그로 감싸기
<form action="http://localhost:3000/process_create" method="post"> // <form>태그의 action속성에 사용자가 입력한 데이터를 수신할 주소를 입력하기 위함.

// 사용자로부터 텍스트를 입력받는 <input>태그 사용, 텍스트를 입력받으러면 type속성값을 'text'로 지정해야 함.
//사용자가 입력한 양식을 웹 서버가 수신해서 용도에 맞게 처리하려면 각 데이터에 이름이 있어야 하므로 name속성에 이름을 부여함.
<p><input type="text" name="title"></p>

// 사용자로부터 여러 줄의 텍스트를 입력받는 <textarea>태그 사용
<p>
  <textarea name="description"></textarea>
</p>

// 사용자가 입력한 데이터를 서버로 전송하는 <submit> 태그 사용
<p>
  <input type="submit">
</p>

</form>

```

사용자가 데이터를 입력하고 [Submit]버튼을 누르면 주소가 바꾸고 주소 표시줄에 입력한 정보가 표시됨 

```jsx
http://localhost:3000/process_create?title=hi&description=lorem

//? 기호를 기준으로 앞은 데이터를 전달한 웹 서버 주소, 뒤는 함께 전달한 쿼리 스트링
```

**웹 서버로 데이터를 전송할 때(post)는** 사용자가 입력한 데이터를 URL에 포함해서 주소 표시줄에 그대로 노출하는 방법은 좋지 않음.

—> **<form>태그의 method속성을 ‘post’로 지정**하여 눈에 보이지 않는 방식으로 전달.

**웹 서버에 있는 데이터를 가져올 때(get)는** 주소 표시줄에 쿼리 스트링이 노출돼도 괜찮음. 해당 주소를 복사해서 다른 사람과 공유해 같은 내용을 볼 수 있기 때문.

method에 post인지 get인지에 따라 데이터 보낼건지 받을건지 알 수 있음.

## 31 App-글 생성 UI만들기

애플리케이션에서 사용자가 글을 쓰는 기능을 지원하려면 웹 페이지에서 어딘가를 클릭했을 때 글쓰기 화면으로 이동하는 링크를 만들어야 함.

```jsx
var http = require('http');
var fs = require('fs');
var url=require('url'); //url모듈이 필요하다고 Node.js에게 요구

function templateHTML(title, list, body){
  return `
  <!doctype html>
  <html>
  <head>
    <title>WEB1 - ${title}</title>
    <meta charset="utf-8">
  </head>
  <body>
    <h1><a href="/">WEB2</a></h1>
    ${list}
    <a href="/create">create</a>
    ${body}
  </body>
  </html>
`;

}

function templateList(filelist){
  var list = '<ul>';
  var i = 0;
  while(i < filelist.length){
    list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
    i = i + 1;
  }
  list = list+'</ul>';
  return list;
}

var app = http.createServer(function(request,response){
    var _url = request.url;
    var queryData=url.parse(_url,true).query; // url.parse(_url,true).query:Node.js의 url모듈에 들어 있는 parse기능 사용 => 웹 브라우저를 통해 요청한 URL을 나타내는 request.url값을 가진 변수를 분석해서 URL중에서 쿼리스트링 문자열만 추출하는 코드
    var pathname=url.parse(_url,true).pathname;// 사용자가 입력한 URL정보 중 경로 이름만 추출하여 저장.
    var title = queryData.id // 제목 출력할 때 ${queryData.id} 대신 ${title} 사용하기 위해 새로운 변수 지정

    //pathname은 쿼리 스트링을 제외한 경로 이름을 가지므로 이것만으로 사용자가 홈을 요청했는지 페이지를 요청했는지 구분할 수가 없음
    // 해결 --> if문으로 쿼리 스트링(queryData.id)이 있다면 홈이 아니고, 쿼리 스트링이 없다면 홈으로 구분하기
    if(pathname ==='/'){
      if(queryData.id===undefined){
        fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
          var title='Welcome';
          var description='Hello, Node.js';
          var list=templateList(filelist);
          var template = templateHTML(title, list, `<h2>${title}</h2>${description}`);
          response.writeHead(200);
          response.end(template); // template 문자열 응답
        });
}
else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = templateList(filelist);
           var template = templateHTML(title, list, `<h2>${title}</h2>${description}`);
           response.writeHead(200);
           response.end(template);// template 문자열 응답
  });
});
}
}else if(pathname==='/create'){
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    var title='WEB-create';
    var list=templateList(filelist);
    var template = templateHTML(title, list, `
    <form action="http://localhost:3000/create_process"method="post">
      <p><input type="text" name="title" placeholder="title"></p>
      <p>
      <textarea name="description" placeholder="description"></textarea>
       </p>
       <p>
       <input type="submit">
       </p>
       </form>
`);
    response.writeHead(200);
    response.end(template); // template 문자열 응답
  });

}else{
  response.writeHead(404);
  response.end('Not found');
}

});
app.listen(3000);

```

—> **create 링크 생성:**글 쓰기 화면으로 이동하는 링크 추가 <a href="/create">create</a>

—> pathname이 /create일 때를 구분

—> pathname이 /create일 때의 동작 정의: template변수를 정의하는 부분에 form.html소스 붙여넣기( 사용자에게 데이터를 입력받기 위한 부분)

—> HTML의 속성 중 하나인 **placeholder**를 사용하여 각 입력 상자에 어떤 정보를 입력해야 하는지 안내

## 32 App-post 방식으로 전송된 데이터 받기

```jsx
var app=http.createSercer(function(request,response){
```

Node.js에서 웹 브라우저로 접속할 때마다 Node.js가 createServer의 콜백 함수를 호출함. createServer로 두 개의 인자를 전달함.(request: 요청할 때 웹 브라우저가 보낸 정보 담겨있음, response: 응답할 때 웹 브라우저에 전송할 정보 담음.)

request.on() 메서드를 두 번 호출할 때 첫 번째 인수를 각각 ‘data’,와 ‘end’로 지정, 두 번째 인수는 서로 다른 콜백 함수를 지정.

- data라는 이벤트: 데이터를 수신할 때마다 발생하므로 콜백에 데이터 처리 기능을 정의
- end라고 하는 이벤트: 데이터 수신을 완료하면 발생하므로 콜백에 데이터 처리를 마무리하는 기능을 정의

**사용자가 create_process경로로 요청했을 때 처리할 수 있게 else if문을 추가)**

```jsx
else if(pathname === '/create_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          var title = post.title;
          var description = post.description
      });
      response.writeHead(200);
      response.end('success');
    }
```

—>POST방식으로 정보 전달 받기

—>POST방식으로 전달 받은 정보를 출력하기

—> data이벤트 콜백에서는 콜백으로 전달받은 인자 data에 담긴 내용을 변수 body에 누적해서 합추기

—>end 이벤트 콜백에서는 qs모듈의 parse기능을 이용해 body에 누적한 내용을 post에 담기, post에 어떤 정보가 담겼는지 확인하기 위해 콘솔에 출력하기

## 33 App-파일 생성과 리다이렉션

### 파일 생성)

post방식으로 전송된 데이터를 가져와서 title과 description변수에 담은 것을 파일 형태로 저장하는 방법

Node.js에서 파일에 데이터를 쓸 때: **writeFile기능** 이용

```jsx
fs.writeFile(file,data[, options],callback)
//(파일 이름, 데이터, 콜백)
```

**데이터를 파일 형태로 저장하기 위한 writeFile()함수**

```jsx
else if(pathname === '/create_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          console.log(post);
          var title = post.title;
          var description = post.description;
          console.log(title);
          console.log(description);
          //fs.writeFile(파일 이름, 파일에 쓸 내용, 파일 저장 인코딩 방식, 파일 쓰기를 마쳤을 때 내부적으로 자동 호츨되는 함수)
          fs.writeFile(`data/${title}`, description, 'utf8',function(err){
            response.writeHead(200);
            response.end('success');// 콜백이 실행되었다는 것은 파일에 저장이 끝났다는 의미이고, 파일 저장이 끝난 후에 success를 츨력해야 하므로 웹 브라우저에 success를 응답하는 코드 여기로 옮김. 
          });

      });
```

—>콜백이 시작됐다는 건 파일에 저장이 끝났다는 의미

—> fs.writeFile의 4번째 인수 function(err) 콜백: err이라는 매개변수를 전달하는데 이는 에러가 있을 때 에러를 처리하는 방법을 제공하는 매개변수

### 리다이렉션)

: 웹 페이지를 이동시키는 기능

파일 저장이 끝난 후에 success로 응답하는 웹 브라우저를 보여주는 것이 아니라 **생성한 파일을 보여주는 페이지로 이동** 

```jsx
localhost:3000/?id=파일명 // 이 경로로 이동하여 보여주고 싶은 것. 
```

**HTTP 상태 코드**

3xx(리다이렉션 완료)

- 301(영구 이동): 사용자가 다른 페이지로 이동시키는데, 이 주소가 영원히 바뀌었다는 의미
- 302(임시 이동): 일시적으로 바뀐 것 의미. 현재 서버가 다른 위치(?id=파일명)에 있는 페이지로 요청에 응답하고 있지만, 사용자가 나중에 다시 요청할 때는 원래 위치(create_process)를 계속 사용해야 함을 의미.

```jsx
fs.writeFile(`data/${title}`, description, 'utf8',function(err){
            response.writeHead(302,{Location:`/?id=${title}`});
            response.end();
```

—>writeHead() 메서드의 첫 번째 인수 302는 페이지를 다른 곳으로 리다이렉션하라는 의미

—> 두 번째 인수는 리다이렉션하고자 하는 경로 의미

```jsx
var http = require('http');
var fs = require('fs');
var url=require('url'); //url모듈이 필요하다고 Node.js에게 요구
var qs = require('querystring');//폼 제출시 post요청을 보내는데 필요한 qs모듈

function templateHTML(title, list, body){
  return `
  <!doctype html>
  <html>
  <head>
    <title>WEB1 - ${title}</title>
    <meta charset="utf-8">
  </head>
  <body>
    <h1><a href="/">WEB</a></h1>
    ${list}
    <a href="/create">create</a>
    ${body}
  </body>
  </html>
`;

}

function templateList(filelist){
  var list = '<ul>';
  var i = 0;
  while(i < filelist.length){
    list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
    i = i + 1;
  }
  list = list+'</ul>';
  return list;
}

var app = http.createServer(function(request,response){
    var _url = request.url;
    var queryData=url.parse(_url,true).query; // url.parse(_url,true).query:Node.js의 url모듈에 들어 있는 parse기능 사용 => 웹 브라우저를 통해 요청한 URL을 나타내는 request.url값을 가진 변수를 분석해서 URL중에서 쿼리스트링 문자열만 추출하는 코드
    var pathname=url.parse(_url,true).pathname;// 사용자가 입력한 URL정보 중 경로 이름만 추출하여 저장.
    var title = queryData.id // 제목 출력할 때 ${queryData.id} 대신 ${title} 사용하기 위해 새로운 변수 지정

    //pathname은 쿼리 스트링을 제외한 경로 이름을 가지므로 이것만으로 사용자가 홈을 요청했는지 페이지를 요청했는지 구분할 수가 없음
    // 해결 --> if문으로 쿼리 스트링(queryData.id)이 있다면 홈이 아니고, 쿼리 스트링이 없다면 홈으로 구분하기
    if(pathname ==='/'){
      if(queryData.id===undefined){
        fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
          var title='Welcome';
          var description='Hello, Node.js';
          var list=templateList(filelist);
          var template = templateHTML(title, list, `<h2>${title}</h2>${description}`);
          response.writeHead(200);
          response.end(template); // template 문자열 응답
        });
}
else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = templateList(filelist);
           var template = templateHTML(title, list, `<h2>${title}</h2>${description}`);
           response.writeHead(200);
           response.end(template);// template 문자열 응답
  });
});
}
}else if(pathname==='/create'){
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    var title='WEB-create';
    var list=templateList(filelist);
    var template = templateHTML(title, list, `
    <form action="http://localhost:3000/create_process"method="post">
      <p><input type="text" name="title" placeholder="title"></p>
      <p>
      <textarea name="description" placeholder="description"></textarea>
       </p>
       <p>
       <input type="submit">
       </p>
       </form>
`);
    response.writeHead(200);
    response.end(template); // template 문자열 응답
  });

}else if(pathname === '/create_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          console.log(post);
          var title = post.title;
          var description = post.description;
          console.log(title);
          console.log(description);
          fs.writeFile(`data/${title}`, description, 'utf8',function(err){
            response.writeHead(302,{Location:`/?id=${title}`});
            response.end();
          })

      });
    }else{
  response.writeHead(404);
  response.end('Not found');
}

});
app.listen(3000);

```

—> create링크를 클릭하고 입력 상자에 데이터를 각각 입력하고 [submit]를 누르면 data디렉터리 아래에 이름으로 파일이 생성되고, 웹 페이지에는 해당 파일 내용이 표시됨. ([submit] 버튼을 누르면 해당 웹 페이지로 이동한 것.

## 34 App-글 수정(수정 링크 생성)

사용자로부터 전달 받은 데이터를 가지고 파일을 생성해서 보여준 해당 데이터를 수정하는 기능

```jsx
var http = require('http');
var fs = require('fs');
var url=require('url'); //url모듈이 필요하다고 Node.js에게 요구
var qs = require('querystring');//폼 제출시 post요청을 보내는데 필요한 qs모듈

function templateHTML(title, list, body, control){
  return `
  <!doctype html>
  <html>
  <head>
    <title>WEB1 - ${title}</title>
    <meta charset="utf-8">
  </head>
  <body>
    <h1><a href="/">WEB</a></h1>
    ${list}
    ${control}
    ${body}
  </body>
  </html>
`;

}

function templateList(filelist){
  var list = '<ul>';
  var i = 0;
  while(i < filelist.length){
    list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
    i = i + 1;
  }
  list = list+'</ul>';
  return list;
}

var app = http.createServer(function(request,response){
    var _url = request.url;
    var queryData=url.parse(_url,true).query; // url.parse(_url,true).query:Node.js의 url모듈에 들어 있는 parse기능 사용 => 웹 브라우저를 통해 요청한 URL을 나타내는 request.url값을 가진 변수를 분석해서 URL중에서 쿼리스트링 문자열만 추출하는 코드
    var pathname=url.parse(_url,true).pathname;// 사용자가 입력한 URL정보 중 경로 이름만 추출하여 저장.
    var title = queryData.id // 제목 출력할 때 ${queryData.id} 대신 ${title} 사용하기 위해 새로운 변수 지정

    //pathname은 쿼리 스트링을 제외한 경로 이름을 가지므로 이것만으로 사용자가 홈을 요청했는지 페이지를 요청했는지 구분할 수가 없음
    // 해결 --> if문으로 쿼리 스트링(queryData.id)이 있다면 홈이 아니고, 쿼리 스트링이 없다면 홈으로 구분하기
    if(pathname ==='/'){
      if(queryData.id===undefined){
        fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
          var title='Welcome';
          var description='Hello, Node.js';
          var list=templateList(filelist);
          var template = templateHTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a>`);
          response.writeHead(200);
          response.end(template); // template 문자열 응답
        });
}
else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = templateList(filelist);
           var template = templateHTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a> <a href="/update">update</a>`);
           response.writeHead(200);
           response.end(template);// template 문자열 응답
  });
});
}
}else if(pathname==='/create'){
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    var title='WEB-create';
    var list=templateList(filelist);
    var template = templateHTML(title, list, `
    <form action="http://localhost:3000/create_process"method="post">
      <p><input type="text" name="title" placeholder="title"></p>
      <p>
      <textarea name="description" placeholder="description"></textarea>
       </p>
       <p>
       <input type="submit">
       </p>
       </form>
`,'');
    response.writeHead(200);
    response.end(template); // template 문자열 응답
  });

}else if(pathname === '/create_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          console.log(post);
          var title = post.title;
          var description = post.description;
          console.log(title);
          console.log(description);
          fs.writeFile(`data/${title}`, description, 'utf8',function(err){
            response.writeHead(302,{Location:`/?id=${title}`});
            response.end();
          })

      });
    }else{
  response.writeHead(404);
  response.end('Not found');
}

});
app.listen(3000);

```

—> **update 링크 생성:** 글 수정 화면으로 이동하는 링크 코드 추가 <a href="/update">update</a>

—> update링크는 글을 수정하는 기능이므로 어떤 글을 선택했을 때(id값이 있을 때만)나오고 홈에서는 안나오도록 함. 

—>control 매개변수를 추가해 페이지의 목적에 맞게 링크 보이기

if문에 해당하는 페이지는 홈이므로 create링크만 표시,

else문에 해당하는 페이지는 id값이 있어서 글 내용을 보여주는 페이지이므로 create와 update링크를 모두 표시,

else if문에 해당하는 글을 작성하는 페이지에서는 두 링크를 모두 보여주지 않아도 되므로 빈 문자열을 나타내는 ‘’만 전달

**update 링크 클릭하면 /update링크로 이동)**

글을 수정하려면 어떤 글을 수정할 것 인지에 대한 정보가 필요→ 수정 대상은 쿼리 스트링을 이용하여 전달함.

```jsx
localhost:3000/update?id=HTML
```

**update링크 수정)**

```jsx
<a href="/update">update</a>

<a href="/update?id=${title}">update</a>
```

—> update링크를 클릭했을 때 이동할 페이지의 id의 값이 title인 쿼리 스트링을 추가함. title은 사용자가 요청한 쿼리 스트링에서 id값이므로 페이지 제목이고, 이는 HTML파일 이름과 같음.

따라서 제목에 해당하는 HTMl파일을 열어서 수정하겠다는 의미

## 35 App-글 수정(수정할 정보 전송)

생성한 update링크를 클릭했을 때 보여줄 화면을 만들고 이 화면에서 수정한 내용을 서버로 전송하는 방법

코드 수정1:

```jsx
else if(pathname === '/update'){
      fs.readdir('./data', function(error, filelist){
        fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
          var title = queryData.id;
          var list = templateList(filelist);
          var template = templateHTML(title, list,
            `
            <form action="/update_process" method="post">
              <input type="hidden" name="id" value="${title}">
              <p><input type="text" name="title" placeholder="title" value="${title}"></p>
              <p>
                <textarea name="description" placeholder="description">${description}</textarea>
              </p>
              <p>
                <input type="submit">
              </p>
            </form>
            `,
            `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
          );
          response.writeHead(200);
          response.end(template);
        });
      });
    }
```

—>경로가 /update일 때 처리하는 else if 문 추가

—> else if문에 파일을 읽어오는 부분 넣기

—> templateHTML함수의 세 번째 인수를 수정해서 사용자에게 글 내용을 수정하는 폼을 제공하도록 변경(글 생성 화면에서 사용한 <form>코드를 활용하여 수정)

코드 수정2:

```jsx
else if(pathname === '/update'){
      fs.readdir('./data', function(error, filelist){
        fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
          var title = queryData.id;
          var list = templateList(filelist);
          var template = templateHTML(title, list,
            `
            <form action="/update_process" method="post">
              <input type="hidden" name="id" value="${title}">
              <p><input type="text" name="title" placeholder="title" value="${title}"></p>
              <p>
                <textarea name="description" placeholder="description">${description}</textarea>
              </p>
              <p>
                <input type="submit">
              </p>
            </form>
            `,
            `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
          );
          response.writeHead(200);
          response.end(template);
        });
      });
    }
```

—> 수정 페이지에서는 [submit]버튼을 클릭하면 update_process로 변경할 데이터를 전송할 텐데, 이때 어떤 데이터를 변경할 것인지 수정할 대상 파일을 알려줘야 함.  바뀌기 전의 title값을 지정할 <input>태그를 추가.(파일명이 해당 웹 페이지 제목으로 사용하고 있으므로 title값 사용, 그런데 사용자가 title을 변경할 수 있으므로 그럼 변경된 파일은 찾을 수가 없을테니 수정하는 정보(변경할 title)과 수정하고자 하는 정보(기존의 title)를 구분해서 전송해야 함. 

—> 사용자가 변경 가능한 폼과 사용자가 변경하면 안되는 두 개의 title이 나옴. 기존의 title은 수정하면 안되므로 HTML의 hidden타입을 사용

⇒ id에는 바뀌기 전의 제목이, title에는 바뀐 제목이 표시됨.

**글 생성 폼에서 변경한 부분)**

1. 사용자가 폼에 데이터를 입력하고 [submit]버튼을 눌렀을 때 데이터를 전달할 경로를 action속성값에  /update_process로 지정(상대 경로로 변경), main.js에서도 ‘http://’~로 시작하는 절대 경로를 상대 경로로 바꾸기
2. 이전에 입력된 내용(파일에서 읽어온 내용)을 표시하기 위해<input>태그에 <value> 태그에 value속성을 추가하고, ${title}값을 넣음.
3. <textarea>태그에는 태그 안쪽에 ${description}을 넣음

—> 각 입력 상자에 이전 내용이 잘 표시됨.\

절대 경로를 상대 경로로 바꾸는 이유)

http://localhost:3000/create_process  —> /create_process

절대 경로로 주소를 작성해두면 [localhost:3000](http://localhost:3000) 일 때만 코드가 동작함. 따라서 도메인 주소를 변경하거나 포트 번호를 바꾸면 코드가 동작하지 않게 됨.  상대 경로는 유연하게 대처 가능함.

## 36 App- 글 수정(수정된 내용 저장)

update_process로 수정된 데이터를 전송했던 데이터를 가져와서 저장하는 update_process요청을 처리하기

```jsx
else if(pathname === '/update_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          var id = post.id;
          var title = post.title;
          var description = post.description;
          fs.rename(`data/${id}`, `data/${title}`, function(error){
            fs.writeFile(`data/${title}`, description, 'utf8', function(err){
              response.writeHead(302, {Location: `/?id=${title}`});
              response.end();
            })
          });
      });
    }
```

—> update_process경로로 요청했을 때 처리하는 코드 추가

—> post방식으로 전달 받은 데이터를 처리해야 하므로 create_process요청을 처리하는 분기에서 이용한 코드 활용

—> id값도 hidden속성으로 전달했으므로 id값을 추가로 전달 받음.

—> 이 애플리케이션에서는 웹 페이지 제목이 파일 이름이므로 파일 이름 변경. fs모듈의 rename기능 이용(첫 번째 인수로 기존 파일명 전달, 두 번째 인수로 사용자가 수정 요청한 제목을 전달, 세 번째 인수는 에러가 발생했을 때 호출되는 콜백)

## 37 App-글 삭제(삭제 버튼 구현)

**[delete]버튼:** 글을 삭제하는 기능 구현 가능

```jsx
if(pathname ==='/'){
      if(queryData.id===undefined){
        fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
          var title='Welcome';
          var description='Hello, Node.js';
          var list=templateList(filelist);
          var template = templateHTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a>`);
          response.writeHead(200);
          response.end(template); // template 문자열 응답
        });
}
else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = templateList(filelist);
           var template = templateHTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a> <a href="/update?id=${title}">update</a> <form><input type="hidden" name="id" value="${title}"><input type="submit" value="delete"></form>`);
           response.writeHead(200);
           response.end(template);// template 문자열 응답
  });
});
}
}
```

글 목록 중 하나를 선택했을 때 [delete]  버튼이 표시되도록 수정

—> 요청 경로에 따라서 다르게 처리하는 분기 문에서 경로가 홈(’/’)이면서 쿼리 스트링이 undefined가 아닐 때를 처리하는 else문 부분에 <a href="/delete?id=${title}">delete</a> 추가함. 

폼 버튼을 이용하여 POST방식으로 처리하도록 수정

—> </form>태그 안의 첫 번째 <input>은 hidden속성으로 사용자에게 보이지 않게 숨기고 소스 코드에서 해당 개체를 식별하는 이름(name)을 id로 지정하고 전송할 값(value 속성)  title(선택한 글 제목)으로 지정

두 번째<input>은 [submit]버튼에 delete가 표시되게 value를 delete로 지정

버튼을 눌렀을 때 delete_process가 삭제 요청을 처리하도록 수정

—> action속성값에 삭제 요청을 처리할 경로를 delete_process로 지정했으며, 요청을 POST방식으로 전송하도록 method속성값을 post로 지정.

- **delete버튼은 누르자마자 바로 삭제됨 —> 링크로 만들면 X**

이유: 링크는 GET방식이므로 클릭했을 때 이동하는 페이지 주소가 웹 브라우저 주소 창에 노출되므로 외부에 유출됐을 때 보안 사고가 발생할 수 있기 때문.

해결 방법

: [update]에서도 링크를 누르면 이동한 페이지에서 폼을 제공하고 [submit]버튼을 이용함으로써  POST방식으로 처리했었음.  [delete]도 POST방식으로 처리해야 함. 

: [delete]버튼을 눌렀을 때 정말로 삭제할 것이지 확인하는 알림창을 뜨도록 설정

```jsx
<form action=”delete_process” method=”post” onsubmit=”return confirm(’정말로 삭제하시겠습니까?’);”>
```

<form>태그에 onsubmit을 추가.

onsubmit: [submit]버튼을 클릭하면 호출되는 이벤트, true를 만나면 action에 있는 주소로 폼 데이터를 전송하고, false를 만나면 폼 데이터를 전송하지 않음.

confirm알림창: [확인]버튼을 클릭하며 true를 반환하고 [취소]버튼을 클릭하면 false반환

## 38 App-글 삭제 기능 완성

사용자가 전송한 정보를 바탕으로 삭제 요청을 처리하는 방법

delete_process경로로 요청하여 글 삭제하지 말고 서버에서 해당 경로를 처리하게 소스를 수정

```jsx
else if(pathname === '/delete_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          var id = post.id;
          fs.unlink(`data/${id}`, function(error){
            response.writeHead(302, {Location: `/`});
            response.end();
          })
      });
    }
```

—> 요청 경로에 따라 다르게 처리하는 분기문에서 else if문을 하나 더 추가하고, 기존의 update_process요청을 처리하는 부분 활용하여 수정

—> 경로를 delete_process로 변경, end이벤트 처리 부분 변경, 전송된 값은 id하나이므로 이 값을 변수에 담음.

—>title변수와 description변수, rename부분은 삭제 기능에는 필요 없으므로 지움.

—> 삭제 끝난 다음에 사용자를 홈으로 보내기(리다이렉션)위해 302 상태 코드에 Location을 ‘/’으로 지정

- Node.js에서 파일을 삭제하는 방법 : fs.unlink() 함수

첫 번째 인수에는 id값을 이용해 삭제할 파일 경로를 전달하고, 두 번째 인수인 콜백 함수에 파일 삭제 완료 후 처리할 내용을 작성.

## 39 자바스크립트-객체의 형식

### 객체Object

- 정보를 순서 없이 정리 정돈하는 데 최적화한 수납 상자
- 숫자가 아닌 이름으로 식별
- 중괄호 사용
- 각 데이터는 콜론을 구분자로 해서 이름과 값의 쌍으로 저장하며, 각 쌍은 쉼표로 구분
- 사용: 객체 이름 다음에 점(.)을 입력하고 이어서 사용하려는 데이터의 이름 입력

### vs

### 배열Array

- 정보를 순서에 따라 정리 정돈하는 데 최적화한 수납 상자
- 고유한 숫자, 즉 인덱스를 가지고 각 정보를 식별
- 대괄호 사용

```jsx
// 배열의 생성과 사용
var members = ['egoing', 'k8805', 'hoya'];
console.log(members[1]); // k8805

//객체의 생성과 사
var roles = {
  'programmer':'egoing',
  'designer' : 'k8805',
  'manager' : 'hoya'
}
console.log(roles.designer); //k8805
console.log(roles['designer']); //k8805

```

⇒ 즉 배열은 데이터를 순서대로 저장하기만 하면 됨, 객체는 데이터에 고유한 이름을 부여해야 함.

## 40 자바스크립트-객체의 반복

반복문을 이용하여 객체에 담겨 있는 데이터를 하나씩 꺼내오는 방법

**배열에 저장된 데이터 순회)**

```jsx
**var members = ['egoing', 'k8805', 'hoya']; //배열
console.log(members[1]); // k8805

var i=0;
while(i<member.length){
  console.log('array loop',members[i]);
  i=i+1;
}**
```

**객체에 저장된 데이터의 이름과 값 순회)**

```jsx
var roles = {
  'programmer':'egoing',
  'designer' : 'k8805',
  'manager' : 'hoya'
}
console.log(roles.designer); //k8805
console.log(roles['designer']);

for(var name in roles){
  console.log('object=>', name, 'value=>', roles[name]);

} 
```

—> for문을 반복할 때마다 in아에 있는 name이라는 변수에는 roles객체의 식별자(키)가 들어오게 약속되어 있음.
—> for~in문에서 in앞에 있는 변수 이름은 꼭 name이 아니어도 괜찮음.

## 41 자바스크립트-객체(값으로서의 함수)

- 서로 연관되어 있는 작업을 함수로 묶고 이름을 붙여 사용함으로써 코드를 서로 연관 짓고 다른 코드와 구분함으로써 처리 작업을 더 효율적으로 가능.
- 자바스크립트의 함수= 처리 작업을 그룹화한 구문= 값(**대입 연산자를 이용하여 함수를 변수에 대입할 수 있다면 함수가 값이라는 의미**)

```jsx
function f1(){
  console.log(1+1);
  console.log(1+2);
}
var i=if(true){console.log(1)}; // if문
// 에러 발생
var w=wile(true){console.log(1)}; // while문
// 에러 발생

var f =function(){
  console.log(1+1);
  console.log(1+2);
}
console.log(f);
f();

//[Function: f]
2
3

var a=[f];
a[0]();
//2
3

var o={
    func:f
}
o.func();
//2
3

```

—> if문, while문은 값이 아니라는 의미

—> f1 함수의 이름을 지워서 익명함수로 만들고 앞에 변수를 선언해서 대입해 보면 에러가 발생하지 않고 함수임도 알려줌

f는 변수이면서 함수이므로 값을 넣어야 하는 자리에 변수 f를 이용할 수 있음. 배열에 넣을 수도 있고 이를 이용하여 함수를 호출할 수도 있음.

—> 객체o를 선언하면서 func라는 이름의 속성에 f를 지정, 객체 o의 func속성에 함수 호출 연산자인()를 붙였더니 f에 대입한 함수가 호출됨.

## 42 자바스크립트-객체(데이터와 값을 담는 그릇으로서의 함수)

자바스크립트에서 함수는 값으로 취급하기도 하므로 배열이나 객체에 담을 수 있다고하지만 함수를 배열에 담는 일은 별로 없고, 주로 객체에 담아서 활용함

—>**객체에서 각 데이터는 이름으로 구분하므로 함수를 사용하기가 편리하기 때문.**

- 함수: 값
- 객체: 값을 담는 그릇

```jsx
var q = {
  v1:'v1',   
  v2:'v2',
  f1:function (){    //함수 f1과 f2를 객체의 멤버로 선언
    console.log(this.v1);  
  },
  f2:function(){
    console.log(this.v2);
  }
}
 
q.f1();
q.f2();
```

- 같은 이름의 함수를 정의하면 기존의 함수(f1)는 삭제되는 것과 마찬가지 이를 해결하기 위한 도구: 객체
- 자바스크립트에서는 함수가 값이므로 객체의 멤버로 추가 가능
- 객체 안에서 자신을 그 이름으로 참조하는 객체 이름이 변경되면 에러가 발생함.—> 객체 안에서 자신을 참조할 때는 자신의 이름에 종속적이지 않게 코드를 작성해야 함: **this키워드 사용(자신을 가리키는 자바스크립트의 키워드)**

## 43 App-템플릿 기능 정리정돈하기

main.js파일에는 template이라는 공통 접두사를 가진 templateHTML과 templateList라는 함수가 존재함 —> 객체를 이용하여 정리정돈

**templateHTML과 templateList함수)**

```jsx
function templateHTML(title, list, body, control){
  return `
  <!doctype html>
  <html>
  <head>
    <title>WEB1 - ${title}</title>
    <meta charset="utf-8">
  </head>
  <body>
    <h1><a href="/">WEB</a></h1>
    ${list}
    ${control}
    ${body}
  </body>
  </html>
`;

}

function templateList(filelist){
  var list = '<ul>';
  var i = 0;
  while(i < filelist.length){
    list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
    i = i + 1;
  }
  list = list+'</ul>';
  return list;
}

// 함수를 호출하는 부분도 수정 전
if(pathname ==='/'){
      if(queryData.id===undefined){
        fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
          var title='Welcome';
          var description='Hello, Node.js';
          var list=templateList(filelist);
          var template = templateHTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a>`);
          response.writeHead(200);
          response.end(template); // template 문자열 응답
        });
}
else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = templateList(filelist);
           var template = templateHTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a> <a href="/update?id=${title}">update</a> <form action="delete_process" method="post" onsubmit="return confirm('정말로 삭제하시겠습니까?');"><input type="hidden" name="id" value="${title}"><input type="submit" value="delete"></form>`);
           response.writeHead(200);
           response.end(template);// template 문자열 응답
  });
});
}
}else if(pathname==='/create'){
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    var title='WEB-create';
    var list=templateList(filelist);
    var template = templateHTML(title, list, `
    <form action="/create_process"method="post">
      <p><input type="text" name="title" placeholder="title"></p>
      <p>
      <textarea name="description" placeholder="description"></textarea>
       </p>
       <p>
       <input type="submit">
       </p>
       </form>
`,'');
    response.writeHead(200);
    response.end(template); // template 문자열 응답
  });

}else if(pathname === '/create_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          console.log(post);
          var title = post.title;
          var description = post.description;
          console.log(title);
          console.log(description);
          fs.writeFile(`data/${title}`, description, 'utf8',function(err){
            response.writeHead(302,{Location:`/?id=${title}`});
            response.end();
          })

      });
    }else if(pathname === '/update'){
      fs.readdir('./data', function(error, filelist){
        fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
          var title = queryData.id;
          var list = templateList(filelist);
          var template = templateHTML(title, list,
            `
            <form action="/update_process" method="post">
              <input type="hidden" name="id" value="${title}">
              <p><input type="text" name="title" placeholder="title" value="${title}"></p>
              <p>
                <textarea name="description" placeholder="description">${description}</textarea>
              </p>
              <p>
                <input type="submit">
              </p>
            </form>
            `,
            `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
          );
          response.writeHead(200);
          response.end(template);
        });
      });
    }
```

**객체를 이용하여 정리)**

```jsx
var template = {
  HTML:function(title, list, body, control){
    return `
    <!doctype html>
    <html>
    <head>
      <title>WEB1 - ${title}</title>
      <meta charset="utf-8">
    </head>
    <body>
      <h1><a href="/">WEB</a></h1>
      ${list}
      ${control}
      ${body}
    </body>
    </html>
    `;
  },list:function(filelist){
    var list = '<ul>';
    var i = 0;
    while(i < filelist.length){
      list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
      i = i + 1;
    }
    list = list+'</ul>';
    return list;
  }
}

// 함수를 호출하는 부분도 수정 후
if(pathname ==='/'){
      if(queryData.id===undefined){
        fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
          var title='Welcome';
          var description='Hello, Node.js';
          var list = template.list(filelist);
          var html = template.HTML(title, list,
           `<h2>${title}</h2>${description}`,
           `<a href="/create">create</a>`
         );
         response.writeHead(200);
         response.end(html);
       });
}else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = template.list(filelist);
           var html = template.HTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a> <a href="/update?id=${title}">update</a> <form action="delete_process" method="post" onsubmit="return confirm('정말로 삭제하시겠습니까?');"><input type="hidden" name="id" value="${title}"><input type="submit" value="delete"></form>`);
           response.writeHead(200);
           response.end(html);// html 문자열 응답
  });
});
}
}else if(pathname==='/create'){
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    var title='WEB-create';
    var list = template.list(filelist);
    var html = template.HTML(title, list, `
    <form action="/create_process"method="post">
      <p><input type="text" name="title" placeholder="title"></p>
      <p>
      <textarea name="description" placeholder="description"></textarea>
       </p>
       <p>
       <input type="submit">
       </p>
       </form>
`,'');
    response.writeHead(200);
    response.end(html); // template 문자열 응답
  });

}else if(pathname === '/create_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          console.log(post);
          var title = post.title;
          var description = post.description;
          console.log(title);
          console.log(description);
          fs.writeFile(`data/${title}`, description, 'utf8',function(err){
            response.writeHead(302,{Location:`/?id=${title}`});
            response.end();
          })

      });
    }else if(pathname === '/update'){
      fs.readdir('./data', function(error, filelist){
        fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
          var title = queryData.id;
          var list = template.list(filelist);
           var html = template.HTML(title, list,
            `
            <form action="/update_process" method="post">
              <input type="hidden" name="id" value="${title}">
              <p><input type="text" name="title" placeholder="title" value="${title}"></p>
              <p>
                <textarea name="description" placeholder="description">${description}</textarea>
              </p>
              <p>
                <input type="submit">
              </p>
            </form>
            `,
            `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
          );
          response.writeHead(200);
          response.end(html);
        });
      });
    }else if(pathname === '/update_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          var id = post.id;
          var title = post.title;
          var description = post.description;
          fs.rename(`data/${id}`, `data/${title}`, function(error){
            fs.writeFile(`data/${title}`, description, 'utf8', function(err){
              response.writeHead(302, {Location: `/?id=${title}`});
              response.end();
            })
          });
      });
    
    }
```

—> template이라는 객체를 선언하면서 속성으로 HTML과 list를 선언

—> 기존 이름은 객체의 속성 이름으로 대체할 것이므로 필요 없음

```jsx
var http = require('http');
var fs = require('fs');
var url=require('url'); //url모듈이 필요하다고 Node.js에게 요구
var qs = require('querystring');//폼 제출시 post요청을 보내는데 필요한 qs모듈

var template = {
  HTML:function(title, list, body, control){
    return `
    <!doctype html>
    <html>
    <head>
      <title>WEB1 - ${title}</title>
      <meta charset="utf-8">
    </head>
    <body>
      <h1><a href="/">WEB</a></h1>
      ${list}
      ${control}
      ${body}
    </body>
    </html>
    `;
  },list:function(filelist){
    var list = '<ul>';
    var i = 0;
    while(i < filelist.length){
      list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
      i = i + 1;
    }
    list = list+'</ul>';
    return list;
  }
}

var app = http.createServer(function(request,response){
    var _url = request.url;
    var queryData=url.parse(_url,true).query; // url.parse(_url,true).query:Node.js의 url모듈에 들어 있는 parse기능 사용 => 웹 브라우저를 통해 요청한 URL을 나타내는 request.url값을 가진 변수를 분석해서 URL중에서 쿼리스트링 문자열만 추출하는 코드
    var pathname=url.parse(_url,true).pathname;// 사용자가 입력한 URL정보 중 경로 이름만 추출하여 저장.
    var title = queryData.id // 제목 출력할 때 ${queryData.id} 대신 ${title} 사용하기 위해 새로운 변수 지정

    //pathname은 쿼리 스트링을 제외한 경로 이름을 가지므로 이것만으로 사용자가 홈을 요청했는지 페이지를 요청했는지 구분할 수가 없음
    // 해결 --> if문으로 쿼리 스트링(queryData.id)이 있다면 홈이 아니고, 쿼리 스트링이 없다면 홈으로 구분하기
    if(pathname ==='/'){
      if(queryData.id===undefined){
        fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
          var title='Welcome';
          var description='Hello, Node.js';
          var list = template.list(filelist);
          var html = template.HTML(title, list,
           `<h2>${title}</h2>${description}`,
           `<a href="/create">create</a>`
         );
         response.writeHead(200);
         response.end(html);
       });
}else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = template.list(filelist);
           var html = template.HTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a> <a href="/update?id=${title}">update</a> <form action="delete_process" method="post" onsubmit="return confirm('정말로 삭제하시겠습니까?');"><input type="hidden" name="id" value="${title}"><input type="submit" value="delete"></form>`);
           response.writeHead(200);
           response.end(html);// html 문자열 응답
  });
});
}
}else if(pathname==='/create'){
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    var title='WEB-create';
    var list = template.list(filelist);
    var html = template.HTML(title, list, `
    <form action="/create_process"method="post">
      <p><input type="text" name="title" placeholder="title"></p>
      <p>
      <textarea name="description" placeholder="description"></textarea>
       </p>
       <p>
       <input type="submit">
       </p>
       </form>
`,'');
    response.writeHead(200);
    response.end(html); // template 문자열 응답
  });

}else if(pathname === '/create_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          console.log(post);
          var title = post.title;
          var description = post.description;
          console.log(title);
          console.log(description);
          fs.writeFile(`data/${title}`, description, 'utf8',function(err){
            response.writeHead(302,{Location:`/?id=${title}`});
            response.end();
          })

      });
    }else if(pathname === '/update'){
      fs.readdir('./data', function(error, filelist){
        fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
          var title = queryData.id;
          var list = template.list(filelist);
           var html = template.HTML(title, list,
            `
            <form action="/update_process" method="post">
              <input type="hidden" name="id" value="${title}">
              <p><input type="text" name="title" placeholder="title" value="${title}"></p>
              <p>
                <textarea name="description" placeholder="description">${description}</textarea>
              </p>
              <p>
                <input type="submit">
              </p>
            </form>
            `,
            `<a href="/create">create</a> <a href="/update?id=${title}">update</a>`
          );
          response.writeHead(200);
          response.end(html);
        });
      });
    }else if(pathname === '/update_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          var id = post.id;
          var title = post.title;
          var description = post.description;
          fs.rename(`data/${id}`, `data/${title}`, function(error){
            fs.writeFile(`data/${title}`, description, 'utf8', function(err){
              response.writeHead(302, {Location: `/?id=${title}`});
              response.end();
            })
          });
      });
    }else if(pathname === '/delete_process'){
      var body = '';
      request.on('data', function(data){
          body = body + data;
      });
      request.on('end', function(){
          var post = qs.parse(body);
          var id = post.id;
          fs.unlink(`data/${id}`, function(error){
            response.writeHead(302, {Location: `/`});
            response.end();
          })
      });
    }

    else{
  response.writeHead(404);
  response.end('Not found');
}

});
app.listen(3000);

```

## 44 Node.js-모듈의 형식

**모듈:** 객체가 많아지면 이 객체를 정리 정돈하는 더 큰 개념의 도구

—> 모듈을 만들어서 객체나 함수를 묶고, 이를 파일로 분리해서 외부에 독립적으로 공유 가능.

```jsx
var M={
  v:'v',
  f:function(){
    console.log(this.v);
  }
}

M.f();

//M이라는 객체 선언, v와 f속성에 각각 값과 함수 정의
// f함수는 자신의 속성 중 v를 출력

파일mpart.js) 
var M={
  v:'v',
  f:function(){
    console.log(this.v);
  }
}

module.exports=M;
//이 파일에 선언한 M객체를 외부에서 사용할 수 있게 하는 자바스크립트 코드.

파일 muse.js)
var part=require('./mpart.js');
console.log(part);
// 다른 파일에서 이렇게 require기능으로 M객체를 선언한 파일의 경로를 지정하여 외부 파일에서 선언된 객체를 사용할 수 있게 되는 것.
part.f()
// 호출연산자 붙여서 실행
```

module.exports=M; 

—> 다른 파일에서도 M객체를 사용할 수 있다는 의미.

## 45 App- 모듈의 활용

애플리케이션의 기능을 main.js파일 한 곳에 모두 구현하여 소스 코드가 긴 상황 —> template객체를 여러 곳에서 사용하므로 이 객체를 모듈화해서 독립적인 외부 파일로 만들어보기

**template.js파일 생성 및 객체 정의**

```jsx
var template = {
  HTML:function(title, list, body, control){
    return `
    <!doctype html>
    <html>
    <head>
      <title>WEB1 - ${title}</title>
      <meta charset="utf-8">
    </head>
    <body>
      <h1><a href="/">WEB</a></h1>
      ${list}
      ${control}
      ${body}
    </body>
    </html>
    `;
  },list:function(filelist){
    var list = '<ul>';
    var i = 0;
    while(i < filelist.length){
      list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
      i = i + 1;
    }
    list = list+'</ul>';
    return list;
  }
}

module.exports=template;

// 객체 정의 다른 방법
module.exports={
    HTML:function(title, list, body, control){
      ...생략...}
}
```

**main.js에서 template.js에 정의한 내용 사용**

```jsx
var template=require('./lib/template.js'); //외부 파일에서 정의한 template 객체 사용

```

## 46 App-입력 정보에 대한 보안

우리가 만든 애플리케이션이 가진 위험 요소: 데이터베이스를 이용하여 데이터 관리하는 방식으로 애플리케이션을 개선해 나갈 때 아이디와 비밀번호가 있어야 하므로 어딘가에 저장해 놓아야 함. 

아이디와 비밀번호가 저장된 파일

```jsx
module.exports={
  id:'egoing',
  password:'111111'
}
```

- 애플리케이션은 사용자가 이 파일의 내용을 화면에 출력 가능함
- 아이디와 비밀번호가 외부에 노출되는 상황 발생

```jsx
fs.readir('./data', function(error,filelist){
   fs.readFile(`data/${queryData.id}`,`utf8`,function(err,description){
```

—> ${queryData.id} 이 부분에 ‘http://localhost:3000/?id=../password.js’라고 입력한다면 화면에 출력됨

—> ../ 는 현재 페이지의 상위 디렉터리에 접근할 수 있다는 의미..

**Node.js의 path.parse()라는 메서드**

path 모듈의 parse메서드를 이용하여 ../password.js의 경로를 분석

⇒ 디렉터리 경로에 해당하는 .. 은 dir이라는 프로퍼티에 분석됨, 확장자인 .js 는 ext프로퍼티로 분류됨, 우리가 사용할 속성은 base(경로에서 파일명만 사용)

```jsx
console>

> path.parse('../password.js');
{
  root: '',
  dir: '..',
  base: 'password.js',
  ext: '.js',
  name: 'password'
}
> path.parse('../password.js').base; // 사용자가 ../password.js라고 입력하더라도 password.js에 해당하는 부분만 사용함으로써 사용자가 입력한 정보를 정제할 수 있음.
'password.js'
```

**사용자로부터 경로 요청을 가져오는 모든 곳을 수정** 

```jsx
//수정 전
else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = template.list(filelist);
           var html = template.HTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a> <a href="/update?id=${title}">update</a> <form action="delete_process" method="post" onsubmit="return confirm('정말로 삭제하시겠습니까?');"><input type="hidden" name="id" value="${title}"><input type="submit" value="delete"></form>`);
           response.writeHead(200);
           response.end(html);// html 문자열 응답
  });
});
}

else if(pathname === '/update'){
      fs.readdir('./data', function(error, filelist){
        fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
          var title = queryData.id;
          var list = template.list(filelist);
           var html = template.HTML(title, list,
            `
```

```jsx
// 수정 후
else {
fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    var filteredID=path.parse(queryData.id).base;
    fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
           var title = queryData.id;
           var list = template.list(filelist);
           var html = template.HTML(title, list, `<h2>${title}</h2>${description}`,`<a href="/create">create</a> <a href="/update?id=${title}">update</a> <form action="delete_process" method="post" onsubmit="return confirm('정말로 삭제하시겠습니까?');"><input type="hidden" name="id" value="${title}"><input type="submit" value="delete"></form>`);
           response.writeHead(200);
           response.end(html);// html 문자열 응답
  });
});
}

else if(pathname === '/update'){
      fs.readdir('./data', function(error, filelist){
        var filteredID=path.parse(queryData.id).base;
        fs.readFile(`data/${filteredID}`, 'utf8', function(err, description){
          var title = queryData.id;
          var list = template.list(filelist);
           var html = template.HTML(title, list,
            `
```

## 47 App- 출력 정보에 대한 보안

 사용자가 입력한 데이터를 조심해야 하는 이유

```jsx
<script>
alert('merong');
</script>

// 사용자가 HTML태그를 이용하여 입력하였을 때 위의 부분에서 alert는 웹 브라우저에서 경고 창을 띄우는 기능이므로 경고창을 표시함. 

<script>
location.href='http://opentutorials.org/course/1';
</script>
// 사용자가 이렇게 입력하였다면 현재 페이지를 벗어나 명시한 페이지가 보이게 됨.
```

⇒ 공격자가 사이트에 자바스크립트 코드를 심어 놓는데 경고창이나 사이트로 연결하는 문제가 생길 수 있음.

**필터링 방법 적용하기** 

```jsx
// <는 &lt; 로 >는 &gt;로 수정하기

&lt;script;&gt
location.href='http://opentutorials.org/course/1';
&lt;/script>&gt;
```

⇒ HTML코드를 일반 문자열처럼 그대로 출력

npm(node Package Manager): 자바스크립트 프로그래밍 언어를 위한 패키지 관리자, npm에 있는 모듈을 이용하면 다른 사람이 만든 모듈을 이용해 애플리케이션을 빠르게 개발 가능.

**sanitize-html 이라는 npm모듈 설치해보기**

```jsx
// npm초기화
>npm init

>npm install -S sanitize-html

```

**상세 보기 페이지를 생성하는 코드에 필터링 기능을 추가하기**

```jsx
else {
  fs.readdir('./data',function(error,filelist){ // 파일 목록을 가져오는 코드
    var filteredID=path.parse(queryData.id).base;
    fs.readFile(`data/${filteredID}`, 'utf8', function(err, description){
           var title = queryData.id;
           var sanitizedTitle=snitizeHtml(title);
           var sannitizedDescription=sanitizeHtml(description);
           var list = template.list(filelist);
           var html = template.HTML(sanitizedTitle, list, `<h2>${sanitizedTitle}</h2>${sanitizedDescription}`,`<a href="/create">create</a> <a href="/update?id=${sanitizedTitle}">update</a> <form action="delete_process" method="post" onsubmit="return confirm('정말로 삭제하시겠습니까?');"><input type="hidden" name="id" value="${sanitizedTitle}"><input type="submit" value="delete"></form>`);
           response.writeHead(200);
           response.end(html);// html 문자열 응답
  });
});
}
```

1. **사용자 입력 처리:** 사용자가 웹 브라우저의 폼을 통해 HTML콘텐츠를 입력
2. **서버에서 입력을 수신하고 필터링:** 서버는 사용자의 입력을 수신하고, 이를 저장하기 전에 sanitize-html 라이브러리를 사용하여 위험한 태그를 필터링 (태그는 제거되고 안전한 콘텐츠만 남김)
3. **필터링된 콘텐츠 저장:** 필터링된 콘텐츠는 데이터베이스에 저장되고 안전한 HTML만 포함
4. **웹 페이지에 출력:** 나중에 웹 페이지에서 이 저장된 콘텐츠를 불러와 출력할 떄는 이미 필터링된 상태이므로 안전하게 사용자에게 보여줄 수 있음.

⇒ 입력한 태그는 그대로 유지되지만(데이터베이스에 저장되기 전에 필터링됨) 웹 페이지에 표시할 때는 sanitize-html로 필터링된 안전한 HTML만 보여주는 것.

**특정 태그를 필터링하지 않고 허용하고 싶다면 sanitizeHtml기능에 옵션 지정하기**
```jsx
 var sanitizedDescription=sanitizeHtml(description,{
            allowedTags:['h1']
           });
```
