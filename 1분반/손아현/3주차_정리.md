# [1장] 자바스크립트와 Node.js (28~)

## 1.28. Node.js - 동기와 비동기 그리고 콜백
### 1) 동기와 비동기
- 동기(synchronous) 처리 방식: 하나의 작업이 끝날 때까지 기다렸다가 다음 작업이 처리하는 방식을 처리하는 방식 **(= 직렬)**
- 비동기(asynchronous) 처리 방식: 병렬로 동시에 여러 가지 일을 처리하는 방식 **(= 병렬)**  

**➡️ Node.js는 비동기 처리 방식으로 작동 가능**

### 2) Node.js에서 비동기 처리
- `Sync`가 <u>있으면</u> **동기 처리 방식**으로 동작
- `Sync`가 <u>없으면</u> **비동기 처리 방식**으로 동작

ex) `syntax/sample.txt`에 `B`란 텍스트가 있다고 해보자
1. 동기 처리 방식 (`readFileSync.(path, option)`)
    ```javascript
    var fs = require('fs');

    console.log('A');
    var result = fs.readFileSync('syntax/sample.txt', 'utf8');
    console.log(result);
    console.log('C');
    ```
    - 매개변수에 `callback`이 존재 X
    - `readFileSync`의 결과가 `result`에 담김
    - `readFileSync` <u>처리가 완료된 이후</u>에 `console.log('C')`가 실행
    > 실행 결과: **_A - B - C_**
2. 비동기 처리 방식 (`readFile.(path, option, callback)`)
    ```javascript
    var fs = require('fs');

    console.log('A');
    fs.readFile('syntax/sample.txt', 'utf8', function(err, result) {
        console.log(result);
    });
    console.log('C');
    ```
    - 매개변수에 `callback` 존재
    - **`readFile`은 아무 결과도 반환하지 않아서 직접 콜백함수를 작성해줘야 함**
    - `readFile` <u>처리가 완료되기 전</u>에 `console.log('C')`가 실행
    > 실행 결과: **_A - C - B_**

### 3) 콜백(Callback)
: 어떤 실행문을 마치면 내부적으로 자동 호출하는 기능  
ex) 언제 끝날지 모르는 함수의 실행이 끝날 때 자동으로 특정 함수를 호출
```javascript
function slowfinc(callback) {
    callback();
}
```
- 콜백을 매개변수로 받아서 호출
- `slowfunc()` 함수를 호출할 때 `slowfunc()`가 실행된 다음에 호출할 함수를 인수로 전달

## 1.29. Node.js - 패키지 매니저와 PM2
### 1) 패키지 매니저
- **패키지:** 소프트웨어를 일컫는 여러가지 표현 중 하나
- **패키지 매니저:** 패키지를 설치, 업데이트, 삭제하는 등 관리를 돕는 프로그램  

➡️ Node.js를 설치할 때 기본적으로 설치되는 패키지 매니저는 **npm**

### 2) PM2
: Node.js로 만든 프로세스를 관리해주는 프로그램  
- <u>PM2는 프로그램을 감시하고 있다가 의도하지 않게 꺼지거나 소스가 변경될 때 자동으로 재시동시킴</u>
- **프로세스**: 동작 중인 프로그램 (해당 프로젝트에선 `main.js`)
1. pm2 설치
    ```bash
    npm install pm2 -g
    ```
    > ⭐ pm2를 깔았는데도 실행되지 않으면 powershell 관리자모드에서 `Get-ExecutionPolicy`, `Set-ExecutionPolicy "RemoteSigned"` 입력하기, pm2 사용 다했으면 다시 `Set-ExecutionPolicy "Restricted"` 로 돌려두기
2. pm2 실행
    ```bash
    pm2 start [프로세스명]
    ```
3. 프로세스 감지
    ```bash
    pm2 monit
    ```
    - 현재 PM2가 감지하는 프로세스의 정보가 나타남
    - 사용자가 PM2를 강제종료해도 PM2가 프로세스를 자동으로 재시동시킴  
    ➡️ PM2는 이러한 기능을 통해 서**비스를 안정적으로 운영할 수 있게 해줌**
4. 프로세스 목록 확인
    ```bash
    pm2 list
    ```
5. 프로세스 중단
    ```bash
    pm2 stop [프로세스명]
    ```
6. ⭐ 소스 파일 감시
    ```bash
    pm2 start [프로세스명] --watch
    ```
    - 해당 방법으로 프로세스를 실행하면 소스코드 수정 후, 프로그램을 재시동하지 않고도 즉시 반영됨
7. 에러 발생 확인
    ```bash
    pm2 log
    ```  
    - 소스 파일이 변경될 때마다 감지 결과를 로그로 보여줌

> ⭐ 6번 코드로 PM2를 켜두면 **① 코드 수정 후 서버를 재실행하지 않고 새로고침해도 자동으로 반영**되고, **② 프로세스를 PM2에서 중단하지 않는 이상 서버가 중단되지 않으**니 유용함!! (대신 끝나면 프로세스 중단 시키기) ➡️ 그럼 이제 매번 따로 `node main.js` 입력해서 서버 실행시키지 않아도 됨
## 1.30. HTML - Form
### 1) 서버에서 데이터를 가져올 때 (GET)
```html
<from action="http://localhost:3000/process_create">
    <p><input type="text" name="title"></p>
    <p>
        <textarea name="description"></textarea>
    </p>
    <p>
        <input type="submit">
    </p>
</from>
```
- 위와 같이 HTML을 작성했을 때, `title`과 `description`에 입력한 내용이 쿼리스트링으로 전달됨  
- `method=get` 작성, 혹은 method를 아예 작성 X 

➡️ `http://localhost:3000/process_create?title=Hello&description=Hello`
### 2) 서버에 데이터를 전송할 때 (POST)
```html
<from action="http://localhost:3000/process_create" method=post>
    <p><input type="text" name="title"></p>
    <p>
        <textarea name="description"></textarea>
    </p>
    <p>
        <input type="submit">
    </p>
</from>
```
- 서버에 데이터를 전달할 때는 **눈에 보이지 않는 방식으로 전달**해야 함
- `method=post`를 작성
- POST 방식을 사용하면 데이터가 주소 표시줄에 나타나지 않아서 안전, 아주 큰 데이터도 전송 가능

➡️ `http://localhost:3000/process_create` 이런식으로 쿼리 스트링이 보이지 않음

### 정리
|method|상황|특징|
|--|--|--|
|"GET" / 생략 |서버에서 데이터를 가져올 때|쿼리 스트링이 URL에 표시 & 데이터 양 제한적|
|"POST"| 서버에 데이터를 전송할 때|쿼리 스트링이 URL에 표시 X  & 데이터 양 제한X|

## 1.31. App - 글 생성 UI 만들기
### 글 생성 버튼 생성 및 데이터 전달(POST)
```javascript
...
function templateHTML(title, list, body) {
  return `
    <!doctype html>
    <html>
      <head>
        <title>WEB1 - ${title}</title>
        <meta charset="utf-8">
      </head>
      <body>
        <h1><a href="/">WEB</a></h1>
        ${list}
        <a href="/create">create</a>
        ${body}
      </body>
    </html>
  `;
}
...
else if(pathname === '/create') {
      fs.readdir('./data', function(error, filelist) {
        var title = 'WEB - create';
        var list = templateList(filelist);
        var template = templateHTML(title, list, `
            <form action="http://localhost:3000/create_process" method="post">
                <p><input type="text" name="title" placeholder="title"></p>
                <p>
                    <textarea name="description" placeholder="description"></textarea>
                </p>
                <p>
                    <input type="submit">
                </p>
            </form>
        `);
        response.writeHead(200);
        response.end(template);
    });
```
- `create`버튼을 누르면 `pathname`이 `/create`가 되도록
- `pathname`이 `/create`이면 `form`이 생겨나도록
- 사용자가 입력한 데이터를 `create_process`로 전달

## 1.32. App - POST 방식으로 전송된 데이터 받기
- `create_process`로 전송된 데이터를 가져오는 방법
### 1) create-process 경로로 요청했을 때 처리하는 코드 추가
```javascript
...
function templateHTML(title, list, body) {
  return `
    <!doctype html>
    <html>
      <head>
        <title>WEB1 - ${title}</title>
        <meta charset="utf-8">
      </head>
      <body>
        <h1><a href="/">WEB</a></h1>
        ${list}
        <a href="/create_process">create</a>
        ${body}
      </body>
    </html>
  `;
}
...
else if(pathname === '/create_process') {
    response.writeHead(200);
    response.end('success');
  }
...
```
- `create` 버튼을 눌렀을 때 `create_process`로 요청 하기

### 2) querystring 모듈 추가
```javascript
...
var qs = require('qs');
...
```

### 3) POST 방식으로 정보 전달 받기
```javascript
...
var qs = require('qs');
...
else if(pathname === '/create_process') {
    var body = '';
    request.on('data', function(data) {

    });
    request.on('end', function() {
      
    });
  }  
...
```
- `request`는 `createServer` 함수의 콜백으로 전달한 인수임 ➡️ `var app = http.createServer(function(request, response) {}`
    - **`request`**: 요청할 때 _웹 브라우저가 보낸_ 정보
    - **`response`**: 응답할 때 _웹 브라우저에 전송할_ 정보
- `request.on('data', function(data) {});` : 데이터를 수신할 때마다 발생
    > ➡️ POST 방식으로 전송하는 데이터의 양이 많을 경우를 대비하여 <u>**데이터를 수신할 때 조각조각 나눠서 수신함**</u>
- `request.on('end', function() {});` : 데이터 수신을 완료하면 발생